{"version":3,"sources":["SoyRenderer.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA0VE,WAAW","file":"bower_components/metal/src/soy/SoyRenderer.js","sourcesContent":["'use strict';\n\nimport core from '../core';\nimport dom from '../dom/dom';\nimport object from '../object/object';\nimport Component from '../component/Component';\nimport ComponentRegistry from '../component/ComponentRegistry';\nimport ComponentRenderer from '../component/ComponentRenderer';\nimport SoyAop from './SoyAop';\nimport SoyTemplates from './SoyTemplates';\n\n// The injected data that will be passed to soy templates.\nvar ijData = {};\n\n/**\n * A `ComponentRenderer` that enables components to be rendered via soy templates. It\n * automatically creates surfaces named after each template and uses template params\n * as render attributes. That means that when an attribute value changes, the templates\n * that have a parameter with the same name will be automatically rendered again.\n * @extends {ComponentRenderer}\n */\nclass SoyRenderer extends ComponentRenderer {\n\t/**\n\t * Adds surfaces from the soy templates.\n\t * @param {!Component} component\n\t * @protected\n\t */\n\tstatic addSurfacesFromTemplates_(component) {\n\t\tvar name = component.getName();\n\t\tvar templates = SoyTemplates.get(name);\n\t\tvar templateNames = Object.keys(templates);\n\t\tfor (var i = 0; i < templateNames.length; i++) {\n\t\t\tvar templateName = templateNames[i];\n\t\t\tvar templateFn = SoyAop.getOriginalFn(templates[templateName]);\n\t\t\tif (SoyRenderer.isSurfaceTemplate_(templateName, templateFn)) {\n\t\t\t\tvar surfaceId = templateName === 'content' ? component.id : templateName;\n\t\t\t\tcomponent.addSurface(surfaceId, {\n\t\t\t\t\trenderAttrs: templateFn.params,\n\t\t\t\t\ttemplateComponentName: name,\n\t\t\t\t\ttemplateName: templateName\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Builds the config data for a component from the data that was passed to its\n\t * soy template function.\n\t * @param {string} id The id of the component.\n\t * @param {!Object} templateData\n\t * @return {!Object} The component's config data.\n\t * @protected\n\t */\n\tstatic buildComponentConfigData_(id, templateData) {\n\t\tvar config = {\n\t\t\tid: id\n\t\t};\n\t\tfor (var key in templateData) {\n\t\t\tconfig[key] = templateData[key];\n\t\t}\n\t\treturn config;\n\t}\n\n\t/**\n\t * Builds the data object that should be passed to a template from the given component.\n\t * @param {!Component} component\n\t * @return {!Object}\n\t * @protected\n\t */\n\tstatic buildTemplateData_(component) {\n\t\tvar names = component.getAttrNames().filter(function(name) {\n\t\t\t// Get all attribute values except for \"element\", since it helps performance and this\n\t\t\t// attribute shouldn't be referenced inside a soy template anyway.\n\t\t\treturn name !== 'element';\n\t\t});\n\t\tvar surface = component.getSurface(component.id);\n\t\tvar data = (surface && surface.componentData) ? surface.componentData : {};\n\t\treturn object.mixin(data, component.getAttrs(names));\n\t}\n\n\t/**\n\t * Creates and instantiates a component that has the given soy template function as its\n\t * main content template. All keys present in the config object, if one is given, will be\n\t * attributes of this component, and the object itself will be passed to the constructor.\n\t * @param {!function()} templateFn\n\t * @param {(Element|string)=} opt_element The element that should be decorated. If none is given,\n\t *   one will be created and appended to the document body.\n\t * @param {Object=} opt_data Data to be passed to the soy template when it's called.\n\t * @return {!Component}\n\t */\n\tstatic createComponentFromTemplate(templateFn, opt_element, opt_data) {\n\t\tvar element = opt_element ? dom.toElement(opt_element) : null;\n\t\tvar data = object.mixin(\n\t\t\t{\n\t\t\t\tid: element ? element.id : null\n\t\t\t},\n\t\t\topt_data,\n\t\t\t{\n\t\t\t\telement: element\n\t\t\t}\n\t\t);\n\n\t\tvar name = 'TemplateComponent' + core.getUid();\n\t\tclass TemplateComponent extends Component {\n\t\t}\n\t\tTemplateComponent.RENDERER = SoyRenderer;\n\t\tComponentRegistry.register(TemplateComponent, name);\n\t\tSoyTemplates.set(name, {\n\t\t\tcontent: function(opt_attrs, opt_ignored, opt_ijData) {\n\t\t\t\treturn SoyAop.getOriginalFn(templateFn)(data, opt_ignored, opt_ijData);\n\t\t\t}\n\t\t});\n\t\tSoyAop.registerTemplates(name);\n\t\treturn new TemplateComponent(data);\n\t}\n\n\t/**\n\t * Decorates html rendered by the given soy template function, instantiating any referenced\n\t * components in it.\n\t * @param {!function()} templateFn\n\t * @param {(Element|string)=} opt_element The element that should be decorated. If none is given,\n\t *   one will be created and appended to the document body.\n\t * @param {Object=} opt_data Data to be passed to the soy template when it's called.\n\t * @return {!Component} The component that was created for this action. Contains\n\t *   references to components that were rendered by the given template function.\n\t * @static\n\t */\n\tstatic decorateFromTemplate(templateFn, opt_element, opt_data) {\n\t\treturn SoyRenderer.createComponentFromTemplate(templateFn, opt_element, opt_data).decorate();\n\t}\n\n\t/**\n\t * Generates the id for a surface that was found by a soy template call.\n\t * @param {!Component} component\n\t * @param {string} parentSurfaceId The id of the parent surface, or undefined\n\t *   if there is none.\n\t * @param {!Object} data The placeholder data registered for this surface.\n\t * @return {string} The generated id.\n\t * @override\n\t */\n\tstatic generateSurfaceElementId(component, parentSurfaceId, data) {\n\t\tif (data.templateName &&\n\t\t\tparentSurfaceId === component.id &&\n\t\t\t!SoyRenderer.firstSurfaceFound_[data.templateName]) {\n\t\t\tSoyRenderer.firstSurfaceFound_[data.templateName] = true;\n\t\t\treturn component.prefixSurfaceId(data.templateName);\n\t\t} else {\n\t\t\treturn component.generateSurfaceElementId(parentSurfaceId);\n\t\t}\n\t}\n\n\t/**\n\t * Renders the appropriate soy template for the specified surface.\n\t * @param {!Object} surface The surface configuration.\n\t * @param {!Component} component The component instance.\n\t * @param {string=} opt_skipContents True if only the element's tag needs to be rendered.\n\t * @return {string}\n\t * @override\n\t */\n\tstatic getSurfaceContent(surface, component, opt_skipContents) {\n\t\tif (surface.surfaceElementId === component.id) {\n\t\t\tif (!surface.renderAttrs) {\n\t\t\t\tthis.addSurfacesFromTemplates_(component);\n\t\t\t}\n\t\t\tSoyRenderer.firstSurfaceFound_ = {};\n\t\t}\n\n\t\tSoyRenderer.surfaceBeingRendered_ = surface.surfaceElementId;\n\t\tSoyRenderer.skipInnerCalls_ = SoyRenderer.skipInnerCalls_ || opt_skipContents;\n\n\t\tvar data = surface.templateData;\n\t\tsurface.templateData = null;\n\t\tvar content = SoyRenderer.renderTemplateByName_(\n\t\t\tcomponent,\n\t\t\tsurface.templateComponentName,\n\t\t\tsurface.templateName,\n\t\t\tdata\n\t\t);\n\n\t\tSoyRenderer.surfaceBeingRendered_ = null;\n\t\tSoyRenderer.skipInnerCalls_ = false;\n\t\treturn content;\n\t}\n\n\t/**\n\t * Handles a call to the SoyRenderer component template.\n\t * @param {!Component} component The component that the call was made for.\n\t * @param {string} componentName The component's name.\n\t * @param {Object} data The data the template was called with.\n\t * @return {string} A placeholder to be rendered instead of the content the template\n\t *   function would have returned.\n\t * @protected\n\t */\n\tstatic handleComponentCall_(component, componentName, data) {\n\t\tvar surfaceData = {\n\t\t\tcomponentName: componentName\n\t\t};\n\t\tvar id = (data || {}).id;\n\t\tif (!id) {\n\t\t\tid = SoyRenderer.generateSurfaceElementId(component, SoyRenderer.surfaceBeingRendered_, surfaceData);\n\t\t}\n\t\tsurfaceData.componentData = SoyRenderer.buildComponentConfigData_(id, data);\n\t\treturn component.buildPlaceholder(id, surfaceData);\n\t}\n\n\t/**\n\t * Handles a call to a soy template.\n\t * @param {!Component} component The component that the call was made for.\n\t * @param {string} templateComponentName The name of the component that this template was belongs to.\n\t * @param {string} templateName The name of this template.\n\t * @param {!function()} originalFn The original template function that was intercepted.\n\t * @param {!Object} data The data the template was called with.\n\t * @param {*} opt_ignored\n\t * @param {Object} opt_ijData Template injected data object.\n\t * @return {string}\n\t * @protected\n\t */\n\tstatic handleInterceptedCall_(component, templateComponentName, templateName, originalFn, data, opt_ignored, opt_ijData) {\n\t\tif (SoyRenderer.skipInnerCalls_) {\n\t\t\treturn '';\n\t\t} else if (templateName === 'content') {\n\t\t\treturn this.handleComponentCall_.call(this, component, templateComponentName, data);\n\t\t} else {\n\t\t\treturn this.handleSurfaceCall_.call(this, component, templateComponentName, templateName, originalFn, data, opt_ignored, opt_ijData);\n\t\t}\n\t}\n\n\t/**\n\t * Handles a call to the SoyRenderer surface template.\n\t * @param {!Component} component\n\t * @param {string} templateComponentName The name of the component that this template was belongs to.\n\t * @param {string} templateName The name of this template.\n\t * @param {!function()} originalFn The original template function that was intercepted.\n\t * @param {!Object} data The data the template was called with.\n\t * @param {*} opt_ignored\n\t * @param {Object} opt_ijData Template injected data object.\n\t * @return {string} A placeholder to be rendered instead of the content the template\n\t *   function would have returned.\n\t * @protected\n\t */\n\tstatic handleSurfaceCall_(component, templateComponentName, templateName, originalFn, data, opt_ignored, opt_ijData) {\n\t\tvar surfaceData = {\n\t\t\tstatic: originalFn.static,\n\t\t\ttemplateComponentName: templateComponentName,\n\t\t\ttemplateData: data,\n\t\t\ttemplateName: templateName\n\t\t};\n\t\tvar surfaceElementId;\n\t\tif (core.isDefAndNotNull(data.surfaceElementId)) {\n\t\t\tsurfaceElementId = data.surfaceElementId;\n\t\t} else if (core.isDefAndNotNull(data.surfaceId)) {\n\t\t\tsurfaceElementId = component.getSurfaceElementId(data.surfaceId.toString());\n\t\t} else {\n\t\t\tif (originalFn.private) {\n\t\t\t\treturn originalFn.call(null, data, opt_ignored, opt_ijData);\n\t\t\t}\n\t\t\tsurfaceElementId = SoyRenderer.generateSurfaceElementId(component, SoyRenderer.surfaceBeingRendered_, surfaceData);\n\t\t}\n\t\treturn component.buildPlaceholder(surfaceElementId, surfaceData);\n\t}\n\n\t/**\n\t * Checks if a template is a surface template.\n\t * @param {string} templateName\n\t * @param {!function()} templateFn\n\t * @return {boolean}\n\t * @protected\n\t */\n\tstatic isSurfaceTemplate_(templateName, templateFn) {\n\t\treturn templateName.substr(0, 13) !== '__deltemplate' && !templateFn.private;\n\t}\n\n\t/**\n\t * Renders the given soy template function, instantiating any referenced components in it.\n\t * @param {!function()} templateFn\n\t * @param {(Element|string)=} opt_element The element that should be decorated. If none is given,\n\t *   one will be created and appended to the document body.\n\t * @param {Object=} opt_data Data to be passed to the soy template when it's called.\n\t * @return {!Component} The component that was created for this action. Contains\n\t *   references to components that were rendered by the given template function.\n\t * @static\n\t */\n\tstatic renderFromTemplate(templateFn, opt_element, opt_data) {\n\t\treturn SoyRenderer.createComponentFromTemplate(templateFn, opt_element, opt_data).render();\n\t}\n\n\t/**\n\t * Renders the specified template.\n\t * @param {!Component} component\n\t * @param {!function()} templateFn\n\t * @param {Object=} opt_data\n\t * @return {string} The template's result content.\n\t * @protected\n\t */\n\tstatic renderTemplate_(component, templateFn, opt_data) {\n\t\tSoyAop.startInterception(SoyRenderer.handleInterceptedCall_.bind(SoyRenderer, component));\n\t\ttemplateFn = SoyAop.getOriginalFn(templateFn);\n\t\tvar content = templateFn(opt_data || SoyRenderer.buildTemplateData_(component), null, ijData).content;\n\t\tSoyAop.stopInterception();\n\t\treturn content;\n\t}\n\n\t/**\n\t * Renders the template with the specified name.\n\t * @param {!Component} component\n\t * @param {string} templateComponentName\n\t * @param {string} templateName\n\t * @param {Object=} opt_data\n\t * @return {string} The template's result content.\n\t * @protected\n\t */\n\tstatic renderTemplateByName_(component, templateComponentName, templateName, opt_data) {\n\t\tvar elementTemplate = SoyTemplates.get(templateComponentName, templateName);\n\t\tif (core.isFunction(elementTemplate)) {\n\t\t\treturn SoyRenderer.renderTemplate_(component, elementTemplate, opt_data);\n\t\t}\n\t}\n\n\t/**\n\t * Sanitizes the given html string, so it can skip escaping when passed to a\n\t * soy template.\n\t * @param {string} html\n\t * @return {soydata.SanitizedHtml}\n\t */\n\tstatic sanitizeHtml(html) {\n\t\treturn soydata.VERY_UNSAFE.ordainSanitizedHtml(html);\n\t}\n\n\t/**\n\t * Sets the injected data object that should be passed to templates.\n\t * @param {Object} data\n\t */\n\tstatic setInjectedData(data) {\n\t\tijData = data || {};\n\t}\n}\n\nvar originalSanitizedHtmlFromFn = soydata.SanitizedHtml.from;\nsoydata.SanitizedHtml.from = function(value) {\n\tif (value && value.contentKind === 'HTML') {\n\t\tvalue = SoyRenderer.sanitizeHtml(value.content);\n\t}\n\treturn originalSanitizedHtmlFromFn(value);\n};\n\n\nexport default SoyRenderer;\n"],"sourceRoot":"/source/"}