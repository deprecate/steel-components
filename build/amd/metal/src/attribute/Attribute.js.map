{"version":3,"sources":["Attribute.js"],"names":[],"mappings":"AAAA,YAAY,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA8gBE,SAAS","file":"bower_components/metal/src/attribute/Attribute.js","sourcesContent":["'use strict';\n\nimport array from '../array/array';\nimport core from '../core';\nimport object from '../object/object';\nimport EventEmitter from '../events/EventEmitter';\nimport async from '../async/async';\n\n/**\n * Attribute adds support for having object properties that can be watched for\n * changes, as well as configured with validators, setters and other options.\n * See the `addAttr` method for a complete list of available attribute\n * configuration options.\n * @constructor\n * @extends {EventEmitter}\n */\nclass Attribute extends EventEmitter {\n\tconstructor(opt_config) {\n\t\tsuper();\n\n\t\t/**\n\t\t * Object with information about the batch event that is currently\n\t\t * scheduled, or null if none is.\n\t\t * @type {Object}\n\t\t * @protected\n\t\t */\n\t\tthis.scheduledBatchData_ = null;\n\n\t\t/**\n\t\t * Object that contains information about all this instance's attributes.\n\t\t * @type {!Object<string, !Object>}\n\t\t * @protected\n\t\t */\n\t\tthis.attrsInfo_ = {};\n\n\t\tthis.setShouldUseFacade(true);\n\t\tthis.mergeInvalidAttrs_();\n\t\tthis.addAttrsFromStaticHint_(opt_config);\n\t}\n\n\t/**\n\t * Adds the given attribute.\n\t * @param {string} name The name of the new attribute.\n\t * @param {Object.<string, *>=} config The configuration object for the new attribute.\n\t *   This object can have the following keys:\n\t *   setter - Function for normalizing new attribute values. It receives the new value\n\t *   that was set, and returns the value that should be stored.\n\t *   validator - Function that validates new attribute values. When it returns false,\n\t *   the new value is ignored.\n\t *   value - The default value for this attribute. Note that setting this to an object\n\t *   will cause all attribute instances to use the same reference to the object. To\n\t *   have each attribute instance use a different reference, use the `valueFn` option\n\t *   instead.\n\t *   valueFn - A function that returns the default value for this attribute.\n\t *   writeOnce - Ignores writes to the attribute after it's been first written to. That is,\n\t *   allows writes only when setting the attribute for the first time.\n\t * @param {*} initialValue The initial value of the new attribute. This value has higher\n\t *   precedence than the default value specified in this attribute's configuration.\n\t */\n\taddAttr(name, config, initialValue) {\n\t\tthis.buildAttrInfo_(name, config, initialValue);\n\t\tObject.defineProperty(this, name, this.buildAttrPropertyDef_(name));\n\t}\n\n\t/**\n\t * Adds the given attributes.\n\t * @param {!Object.<string, !Object>} configs An object that maps the names of all the\n\t *   attributes to be added to their configuration objects.\n\t * @param {!Object.<string, *>} initialValues An object that maps the names of\n\t *   attributes to their initial values. These values have higher precedence than the\n\t *   default values specified in the attribute configurations.\n\t * @param {boolean|Object=} opt_defineContext If value is false\n\t *     `Object.defineProperties` will not be called. If value is a valid\n\t *     context it will be used as definition context, otherwise `this`\n\t *     will be the context.\n\t */\n\taddAttrs(configs, initialValues, opt_defineContext) {\n\t\tinitialValues = initialValues || {};\n\t\tvar names = Object.keys(configs);\n\n\t\tvar props = {};\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tvar name = names[i];\n\t\t\tthis.buildAttrInfo_(name, configs[name], initialValues[name]);\n\t\t\tprops[name] = this.buildAttrPropertyDef_(name);\n\t\t}\n\n\t\tif (opt_defineContext !== false) {\n\t\t\tObject.defineProperties(opt_defineContext || this, props);\n\t\t}\n\t}\n\n\t/**\n\t * Adds attributes from super classes static hint `MyClass.ATTRS = {};`.\n\t * @param {!Object.<string, !Object>} configs An object that maps the names\n\t *     of all the attributes to be added to their configuration objects.\n\t * @protected\n\t */\n\taddAttrsFromStaticHint_(config) {\n\t\tvar ctor = this.constructor;\n\t\tvar defineContext = false;\n\t\tif (Attribute.mergeAttrsStatic(ctor)) {\n\t\t\tdefineContext = ctor.prototype;\n\t\t}\n\t\tthis.addAttrs(ctor.ATTRS_MERGED, config, defineContext);\n\t}\n\n\t/**\n\t * Checks that the given name is a valid attribute name. If it's not, an error\n\t * will be thrown.\n\t * @param {string} name The name to be validated.\n\t * @throws {Error}\n\t */\n\tassertValidAttrName_(name) {\n\t\tif (this.constructor.INVALID_ATTRS_MERGED[name]) {\n\t\t\tthrow new Error('It\\'s not allowed to create an attribute with the name \"' + name + '\".');\n\t\t}\n\t}\n\n\t/**\n\t * Builds the info object for the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t * @param {Object} config The config object of the attribute.\n\t * @param {*} initialValue The initial value of the attribute.\n\t * @protected\n\t */\n\tbuildAttrInfo_(name, config, initialValue) {\n\t\tthis.assertValidAttrName_(name);\n\n\t\tthis.attrsInfo_[name] = {\n\t\t\tconfig: config || {},\n\t\t\tinitialValue: initialValue,\n\t\t\tstate: Attribute.States.UNINITIALIZED\n\t\t};\n\t}\n\n\t/**\n\t * Builds the property definition object for the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t * @return {!Object}\n\t * @protected\n\t */\n\tbuildAttrPropertyDef_(name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn this.getAttrValue_(name);\n\t\t\t},\n\t\t\tset: function(val) {\n\t\t\t\tthis.setAttrValue_(name, val);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * Calls the requested function, running the appropriate code for when it's\n\t * passed as an actual function object or just the function's name.\n\t * @param {!Function|string} fn Function, or name of the function to run.\n\t * @param {!Array} An optional array of parameters to be passed to the\n\t *   function that will be called.\n\t * @return {*} The return value of the called function.\n\t * @protected\n\t */\n\tcallFunction_(fn, args) {\n\t\tif (core.isString(fn)) {\n\t\t\treturn this[fn].apply(this, args);\n\t\t} else if (core.isFunction(fn)) {\n\t\t\treturn fn.apply(this, args);\n\t\t}\n\t}\n\n\t/**\n\t * Calls the attribute's setter, if there is one.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} value The value to be set.\n\t * @return {*} The final value to be set.\n\t */\n\tcallSetter_(name, value) {\n\t\tvar info = this.attrsInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.setter) {\n\t\t\tvalue = this.callFunction_(config.setter, [value]);\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Calls the attribute's validator, if there is one.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t */\n\tcallValidator_(name, value) {\n\t\tvar info = this.attrsInfo_[name];\n\t\tvar config = info.config;\n\t\tif (config.validator) {\n\t\t\treturn this.callFunction_(config.validator, [value]);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks if the it's allowed to write on the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t * @return {boolean}\n\t */\n\tcanSetAttribute(name) {\n\t\tvar info = this.attrsInfo_[name];\n\t\treturn !info.config.writeOnce || !info.written;\n\t}\n\n\t/**\n\t * @inheritDoc\n\t */\n\tdisposeInternal() {\n\t\tsuper.disposeInternal();\n\t\tthis.attrsInfo_ = null;\n\t\tthis.scheduledBatchData_ = null;\n\t}\n\n\t/**\n\t * Emits the attribute change batch event.\n\t * @protected\n\t */\n\temitBatchEvent_() {\n\t\tif (!this.isDisposed()) {\n\t\t\tvar data = this.scheduledBatchData_;\n\t\t\tthis.scheduledBatchData_ = null;\n\t\t\tthis.emit('attrsChanged', data);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the requested attribute.\n\t * Note: this can and should be accomplished by accessing the attribute as a regular property.\n\t * This should only be used in cases where a function is actually needed.\n\t * @param {string} name\n\t * @return {*}\n\t */\n\tget(name) {\n\t\treturn this[name];\n\t}\n\n\t/**\n\t * Gets the config object for the requested attribute.\n\t * @param {string} name The attribute's name.\n\t * @return {Object}\n\t * @protected\n\t */\n\tgetAttrConfig(name) {\n\t\treturn (this.attrsInfo_[name] || {}).config;\n\t}\n\n\t/**\n\t * Returns an object that maps attribute names to their values.\n\t * @param {Array<string>=} opt_names A list of names of the attributes that should be\n\t *   returned. If none is given, all attributes will be returned.\n\t * @return {Object.<string, *>}\n\t */\n\tgetAttrs(opt_names) {\n\t\tvar attrsMap = {};\n\t\tvar names = opt_names || this.getAttrNames();\n\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tattrsMap[names[i]] = this[names[i]];\n\t\t}\n\n\t\treturn attrsMap;\n\t}\n\n\t/**\n\t * Returns an array with all attribute names.\n\t * @return {Array.<string>}\n\t */\n\tgetAttrNames() {\n\t\treturn Object.keys(this.attrsInfo_);\n\t}\n\n\t/**\n\t * Gets the value of the specified attribute. This is passed as that attribute's\n\t * getter to the `Object.defineProperty` call inside the `addAttr` method.\n\t * @param {string} name The name of the attribute.\n\t * @return {*}\n\t * @protected\n\t */\n\tgetAttrValue_(name) {\n\t\tthis.initAttr_(name);\n\n\t\treturn this.attrsInfo_[name].value;\n\t}\n\n\t/**\n\t * Informs of changes to an attributes value through an event. Won't trigger\n\t * the event if the value hasn't changed or if it's being initialized.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} prevVal The previous value of the attribute.\n\t * @protected\n\t */\n\tinformChange_(name, prevVal) {\n\t\tif (this.shouldInformChange_(name, prevVal)) {\n\t\t\tvar data = {\n\t\t\t\tattrName: name,\n\t\t\t\tnewVal: this[name],\n\t\t\t\tprevVal: prevVal\n\t\t\t};\n\t\t\tthis.emit(name + 'Changed', data);\n\t\t\tthis.scheduleBatchEvent_(data);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the specified attribute, giving it a first value.\n\t * @param {string} name The name of the attribute.\n\t * @protected\n\t */\n\tinitAttr_(name) {\n\t\tvar info = this.attrsInfo_[name];\n\t\tif (info.state !== Attribute.States.UNINITIALIZED) {\n\t\t\treturn;\n\t\t}\n\n\t\tinfo.state = Attribute.States.INITIALIZING;\n\t\tthis.setInitialValue_(name);\n\t\tif (!info.written) {\n\t\t\tinfo.state = Attribute.States.INITIALIZING_DEFAULT;\n\t\t\tthis.setDefaultValue_(name);\n\t\t}\n\t\tinfo.state = Attribute.States.INITIALIZED;\n\t}\n\n\t/**\n\t * Merges an array of values for the ATTRS property into a single object.\n\t * @param {!Array} values The values to be merged.\n\t * @return {!Object} The merged value.\n\t * @static\n\t * @protected\n\t */\n\tstatic mergeAttrs_(values) {\n\t\treturn object.mixin.apply(null, [{}].concat(values.reverse()));\n\t}\n\n\t/**\n\t * Merges the ATTRS static variable for the given constructor function.\n\t * @param  {!Function} ctor Constructor function.\n\t * @return {boolean} Returns true if merge happens, false otherwise.\n\t * @static\n\t */\n\tstatic mergeAttrsStatic(ctor) {\n\t\treturn core.mergeSuperClassesProperty(ctor, 'ATTRS', Attribute.mergeAttrs_);\n\t}\n\n\t/**\n\t * Merges the values of the `INVALID_ATTRS` static for the whole hierarchy of\n\t * the current instance.\n\t * @protected\n\t */\n\tmergeInvalidAttrs_() {\n\t\tcore.mergeSuperClassesProperty(this.constructor, 'INVALID_ATTRS', function(values) {\n\t\t\treturn array.flatten(values).reduce(function(merged, val) {\n\t\t\t\tif (val) {\n\t\t\t\t\tmerged[val] = true;\n\t\t\t\t}\n\t\t\t\treturn merged;\n\t\t\t}, {});\n\t\t});\n\t}\n\n\t/**\n\t * Removes the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t */\n\tremoveAttr(name) {\n\t\tthis.attrsInfo_[name] = null;\n\t\tdelete this[name];\n\t}\n\n\t/**\n\t * Schedules an attribute change batch event to be emitted asynchronously.\n\t * @param {!Object} attrChangeData Information about an attribute's update.\n\t * @protected\n\t */\n\tscheduleBatchEvent_(attrChangeData) {\n\t\tif (!this.scheduledBatchData_) {\n\t\t\tasync.nextTick(this.emitBatchEvent_, this);\n\t\t\tthis.scheduledBatchData_ = {\n\t\t\t\tchanges: {}\n\t\t\t};\n\t\t}\n\n\t\tvar name = attrChangeData.attrName;\n\t\tvar changes = this.scheduledBatchData_.changes;\n\t\tif (changes[name]) {\n\t\t\tchanges[name].newVal = attrChangeData.newVal;\n\t\t} else {\n\t\t\tchanges[name] = attrChangeData;\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the requested attribute.\n\t * Note: this can and should be accomplished by setting the attribute as a regular property.\n\t * This should only be used in cases where a function is actually needed.\n\t * @param {string} name\n\t * @param {*} value\n\t * @return {*}\n\t */\n\tset(name, value) {\n\t\tthis[name] = value;\n\t}\n\n\t/**\n\t * Sets the value of all the specified attributes.\n\t * @param {!Object.<string,*>} values A map of attribute names to the values they\n\t *   should be set to.\n\t */\n\tsetAttrs(values) {\n\t\tvar names = Object.keys(values);\n\n\t\tfor (var i = 0; i < names.length; i++) {\n\t\t\tthis[names[i]] = values[names[i]];\n\t\t}\n\t}\n\n\t/**\n\t * Sets the value of the specified attribute. This is passed as that attribute's\n\t * setter to the `Object.defineProperty` call inside the `addAttr` method.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} value The new value of the attribute.\n\t * @protected\n\t */\n\tsetAttrValue_(name, value) {\n\t\tif (!this.canSetAttribute(name) || !this.validateAttrValue_(name, value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar info = this.attrsInfo_[name];\n\t\tif (info.initialValue === undefined && info.state === Attribute.States.UNINITIALIZED) {\n\t\t\tinfo.state = Attribute.States.INITIALIZED;\n\t\t}\n\n\t\tvar prevVal = this[name];\n\t\tinfo.value = this.callSetter_(name, value);\n\t\tinfo.written = true;\n\t\tthis.informChange_(name, prevVal);\n\t}\n\n\t/**\n\t * Sets the default value of the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t * @return {*}\n\t */\n\tsetDefaultValue_(name) {\n\t\tvar config = this.attrsInfo_[name].config;\n\n\t\tif (config.value !== undefined) {\n\t\t\tthis[name] = config.value;\n\t\t} else {\n\t\t\tthis[name] = this.callFunction_(config.valueFn);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the initial value of the requested attribute.\n\t * @param {string} name The name of the attribute.\n\t * @return {*}\n\t */\n\tsetInitialValue_(name) {\n\t\tvar info = this.attrsInfo_[name];\n\t\tif (info.initialValue !== undefined) {\n\t\t\tthis[name] = info.initialValue;\n\t\t\tinfo.initialValue = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Checks if we should inform about an attributes update. Updates are ignored\n\t * during attribute initialization. Otherwise, updates to primitive values\n\t * are only informed when the new value is different from the previous\n\t * one. Updates to objects (which includes functions and arrays) are always\n\t * informed outside initialization though, since we can't be sure if all of\n\t * the internal data has stayed the same.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} prevVal The previous value of the attribute.\n\t * @return {boolean}\n\t */\n\tshouldInformChange_(name, prevVal) {\n\t\tvar info = this.attrsInfo_[name];\n\t\treturn (info.state === Attribute.States.INITIALIZED) &&\n\t\t\t(core.isObject(prevVal) || prevVal !== this[name]);\n\t}\n\n\t/**\n\t * Validates the attribute's value, which includes calling the validator defined\n\t * in the attribute's configuration object, if there is one.\n\t * @param {string} name The name of the attribute.\n\t * @param {*} value The value to be validated.\n\t * @return {boolean} Flag indicating if value is valid or not.\n\t */\n\tvalidateAttrValue_(name, value) {\n\t\tvar info = this.attrsInfo_[name];\n\n\t\treturn info.state === Attribute.States.INITIALIZING_DEFAULT ||\n\t\t\tthis.callValidator_(name, value);\n\t}\n}\n\n/**\n * A list with attribute names that will automatically be rejected as invalid.\n * Subclasses can define their own invalid attributes by setting this static\n * on their constructors, which will be merged together and handled automatically.\n * @type {!Array<string>}\n */\nAttribute.INVALID_ATTRS = ['attrs'];\n\n/**\n * Constants that represent the states that an attribute can be in.\n * @type {!Object}\n */\nAttribute.States = {\n\tUNINITIALIZED: 0,\n\tINITIALIZING: 1,\n\tINITIALIZING_DEFAULT: 2,\n\tINITIALIZED: 3\n};\n\nexport default Attribute;\n"],"sourceRoot":"/source/"}